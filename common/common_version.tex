\documentclass[12pt, a4paper, onecolumn]{article}
\usepackage{fontspec}
\usepackage{titlesec}
\usepackage{tocloft}
\usepackage[english]{babel}
\usepackage{blindtext}
\usepackage{subfig}
\usepackage{pgf}
\setmainfont{Georgia}
\usepackage{parskip}
\usepackage{float}
\usepackage{multicol}
\usepackage{unicode-math}
\usepackage[margin=3cm]{geometry}

\newcommand\sectionfont{\normalfont\fontspec{Arial}\fontsize{14pt}{0}\bfseries}
\newcommand\subsectionfont{\normalfont\fontspec{Arial}\fontsize{13pt}{0}\bfseries}
\newcommand\subsubsectionfont{\normalfont\fontspec{Arial}\fontsize{12pt}{0}\bfseries}
\newcommand\tocsectionfont{\normalfont\fontspec{Arial}\fontsize{12pt}{0}\bfseries}
\newcommand\tocsubsectionfont{\normalfont\fontspec{Arial}\fontsize{11pt}{0}\bfseries}
\newcommand\tocsubsubsectionfont{\normalfont\fontspec{Arial}\fontsize{11pt}{0}}
\newcommand\toctitlefont{\normalfont\fontspec{Arial}\fontsize{16pt}{0}\bfseries}

\titleformat{\section}{\sectionfont}{\thesection}{20pt}{}
\titleformat{\subsection}{\subsectionfont}{\thesubsection}{20pt}{}
\titleformat{\subsubsection}{\subsubsectionfont}{\thesubsubsection}{20pt}{}

\renewcommand{\cftsecfont}{\tocsectionfont}
\renewcommand{\cftsubsecfont}{\tocsubsectionfont}
\renewcommand{\cftsubsubsecfont}{\tocsubsubsectionfont}
\renewcommand{\cftsecpagefont}{\tocsectionfont}
\renewcommand{\cftsubsecpagefont}{\tocsubsectionfont}
\renewcommand{\cftsubsubsecpagefont}{\tocsubsubsectionfont}
\renewcommand{\cfttoctitlefont}{\toctitlefont}

\newcommand{\parag}[1]{
	\textbf{#1} \hspace{0pt} \\
}

\addto\captionsenglish{
	\renewcommand{\contentsname}{Table of Contents}
}

\begin{document}
	
	\title{Fall detection using smartphone application}
	\maketitle

	\tableofcontents
	\newpage
	
	\section{Introduction}
	
	Accidents related to falling is a major issue in our society. In fact, according to the World Health Organization, "Falls are the second leading cause of accidental or unintentional injury deaths worldwide" \cite{who}. Globally, an average of 37.3 million people (Jan 2018) suffer from injuries related to a fall each year, which are severe enough to seek medical attention. Out of these, no less than an estimated 640 000 individuals die as a direct consequence of the fall \cite{who}. Fall  related accidents are therefore to be considered as a significant world wide health problem. 
	
	Although age is identified as a key driving factor behind fall related injuries, it is not by far the only reason that people hurt themselves this way every year.  Other risk factors include 
	\begin{itemize}
		\item Occupations which require you to work at an elevated height.
		\item Alcohol and substance abuse.
		\item Medical conditions contributing to a reduced sense of balance or vision.
		\item Sporting.	
	\end{itemize}
	
	In Sweden alone, statistics shows even darker figures. Here, falling is the single one reason responsible for the greatest number of accident related fatalities, hospitalizations, and visits to emergency clinics, outnumbering traffic accidents, who come in second \cite[p~3,5]{msb_report}. On top of that, in Sweden, falling is together with poisoning, the type of accident who poses the biggest annual growth, having duplicated the amount of yearly incidents since 2000 \cite{soc_olyckor}. Studies have also shown that peoples perception target traffic accidents as the the most common cause of the above \cite[p~5]{msb_report}. That is however not true, but a reasonable explanation for this is according to MSB (Swedish Civil Contingencies Agency) that most fall related accidents happen in a domestic area and are thus not as dramatic as a car accident or a fire for example. This tend to give this type of accident less space in the common media. 
	
		\subsection{Background}
		
		Work environments are a common ground for falling accidents. The work force in Sweden is by no means an exception to this. The swedish work environment authority (Arbetsmilj√∂verket) published a study in 2016, claiming that fall accidents are the most versus second most common reason for absence in work due to accident, for women and men respectively \cite[p~1]{av}. This does not only have an impact on the lives of the individual and his or her family, it also poses serious economical damage to the society in general, and the affected organizations in particular. The diagrams shown in figure \ref{fig:Men-Women-Falling-From-Same-Ellevation} and \ref{fig:Men-And-Women-Falling-Form-Elevated-height} illustrates the amount of reported fall related accidents per 1000 employed men and women respectively, in the most affected occupations . 
		
		\begin{figure}[h]
			\centering
			\subfloat{{\includegraphics[width=14cm]{../img/Fall_from_ground_women_and_men.png} }}%
			\qquad

			\caption{Work areas with most reported fall accidents from standing level. Amount per 1000 employed women and men respectively}%
			\label{fig:Men-Women-Falling-From-Same-Ellevation}%
		\end{figure}
		
		\begin{figure}[h]
			\centering
			\subfloat{{\includegraphics[width=14cm]{../img/Falls_from_elevated_height_men_and_women.png} }}%
			\qquad
			\caption{Work areas with most reported fall accidents from elevated level. Amount per 1000 employed women and men respectively}%
			\label{fig:Men-And-Women-Falling-Form-Elevated-height}%
		\end{figure}
	
			In relation to the above statistics, minimizing the duration between the occurrence of the fall accident and treatment can in some cases be imperative. This is especially the case where significant trauma to the head is present. In such cases, the sooner an injured person gets treatment, the better the odds of recovering. In cases where a fall accident is occurring in the presence of others, reporting the accident to a medical professional might often be a quick task. However, many fall accidents occur without any other human being around to detect it. In such cases, and especially if the victim is unconscious, alerting medical staff might not be possible.
		
		
		\subsection{Problem}
		
		Falling accidents are common, and it is important that a person who suffers an accident, is aided as quickly as possible to minimize the consequences of the accident. Since a person who suffers a fall may end up in a situation where the person is unable to call for help, for example, because the person is injured or unconscious, an application that could send an automatic alarm could be of great use. An automatic alarm would help minimize the time between the accident and help arriving. Without the alarm, it could take a long time before the person is found by passers-by. For this reason, we want to investigate the possibility of creating a mobile application that can detect falling accidents and report to registered contacts. A mobile application has the advantage that most people already have a smartphone, so if a mobile application could accomplish the task successfully, the cost would be minimized since there will be no need for additional hardware.
		
		This leads us to wonder if it is possible to create such an application. It may be difficult to achieve accuracy in fall detection using only the sensors in the mobile phones that exists on the market today. And if falls were successfully detected, would it be possible to filter out other activities in daily life that resembles falls such as running, jumping or sitting down fast and remain only with the actual falling accidents?
		
		Another question that arises is the fact that this kind of application may have a significant impact on battery life, since it would be necessary to continuously read the sensor values. If the application would drain the battery on the mobile phone, it would make the application far less valuable, since it is unlikely that it would be used.
		
		\subsection{Problem Statement}
		
		This study aims to answer the following:
		
		\textbf{RQ1} \textit{How can a mobile application, that detects falling accidents using modern smartphones, be created?}
		
		\textbf{RQ2} \textit{How will such an application affect the battery life of the mobile phone?}
		
		
		\subsection{Purpose}
		
		The purpose of this study is to examine the possibility of creating an application that uses the sensors available in smartphones on the market today to detect falling accidents. This knowledge will be useful for developers interested in creating fall detection software, since it will provide solutions to the problems that we encountered during development.
		
		\subsection{Limitations}

		The main focus for this study will be fall detection. We will not prioritize user interfaces and integration with other functionality.
		
		\subsection{Goal}
		
		The goal of the project is to create an application that, in an effective way, can detect falling accidents and inform concerned contacts. This application should target employees in fields such as operations, construction, etc., and should run in the users cell phone. The user of the application should be able to register contact information to relatives, colleagues, etc. After that the user can activate the protection in the application by selecting the appropriate option, for example by pressing a button in the application. The user is supposed to do this before starting a critical operation, such as performing work on an elevated height or similar. When the protection in the application is activated, the application makes use of the device's embedded accelerometer to register changes in velocity. If the user would carry the device running the application with the protection actived, while the user would suffer a falling accident, the application would detect this and enter a warning state. In the warning state the application will notify the user that a fall has been detected and that the application soon will send an alarm to registered contacts. If the time limit for the warning state exceeds without any action from the user, an alarm will be sent to the registered contacts using for example SMS.
		
		\subsection{Sustainability \& Ethics}
		
		This section describes some important questions regarding the sustainability \& ethics of the project.
		
		\subsubsection{Sustainability}
		
		Since the application will not replace any existing technology, it is difficult to discuss in which way the application will affect the environment. Our project will be focusing on software alone and will only use hardware that already exists, and thus it will not affect the environment in greater extent. One could however argue that the application will run on a cell phone, which will draw more current if it runs an additional application in the background. Therefore, our project will affect the environment, but it is hard to say how great such an effect will be.
		
		From a social perspective we hope that the application will contribute to the society in a positive way, since the intention is that the application will help to minimize the negative consequences of accidents related to falling. Hopefully, the finished application will contribute to a better working environment for the users of the application, since an accident may be discovered earlier.  
		
		\subsubsection{Ethics}
		
		One important question when it comes to ethics is how personal data in the application will be handled. The users of the application will need to enter things like password, email address, etc., which should be regarded as sensitive data that must not be viewed by a third party. We need to make sure that the application does not have any obvious security vulnerability, that makes it possible for a malicious person or organization to acquire the sensitive data in the application.
		
		Another important question is what guarantees the application provides to its users. Since the application is supposed to help users in case of an accident, it will be negative if the application turns out to function worse than the users expected. The cases when the user is involved in an accident, but the application fails to register this, must be kept to a minimum. But it must also be clear in the description of the application that such cases may occur.
		
		\subsection{Methods}
		
		The first part of the research will be to perform a literature study, where we will gain deeper knowledge in the subject, and find out what earlier attempts have been made to solve this problem. The literature study will give a good starting point for the rest of the study. The next step will be a case study where we develop a mobile application that uses sensors available in smartphones to achieve accurate fall detection. Developing such an application will give us the opportunity to test theories and ideas found in the literature study. Lastly, the applications impact on battery life will be tested by performing experiments using mobile phones running the application.
		
		\subsection{Disposition}
		
		In chapter \ref{section:theoretical-background}, the theoretical background is described. This includes related works, description of a similar existing application and some theory related to machine learning.
		
		Chapter \ref{section:methods} describes the methods \& methodology used in the project. This includes the research strategy, describing how the application is developed and how it is evaluated.
		
		The results of the first part of the case study is presented in chapter \ref{section:application-design}. The architecture of the developed application is described with enough detail to allow the reader to implement a similar application.
		
		In chapter \ref{section:application-evaluation}, the results of the evaluation is presented. This chapter shows the outcome of the tests performed during evaluation.
		
		Chapter \ref{section:discussion} summarizes and discusses the result, and presents the conclusions of the study.
	\newpage
	
	\section{Theoretical Background} \label{section:theoretical-background}
	
	This chapter describes the theoretical background related to the project.
	
	\subsection{The physics of falling}
	The physics of falling have been researched on several occasions and the results can be read in a multitude of scientific papers and reports. Much of the research done in this area tries to distinguish the characteristics of a fall in comparison to other motional patterns conducted on a daily basis. For a fall detection system to be considered as reliable it is imperative that it has the means to separate actual fall accidents from other patterns resulting from activities of daily living (further referenced as ADL) to a fair extent. The earth's gravitational pull produces a constant acceleration by 9.8 $m/s^{2}$ towards the ground. This constant acceleration is also referenced as \textit{g}. A fall towards the earth's surface would thus initially mean a decrease in acceleration with respect to this natural constant, followed by a rapid acceleration in the other direction as the device (and possibly the person wearing it) hits either the ground or another surface.
	
	
	\subsection{Related works} Two related works have been researched prior as means of background for this thesis. The first one is a paper produced by Yidirim et al. \cite{int_journ} and the other one is a report produced by Abbate et al. \cite{piza_uni}. The both aim to produce an application embedded on an Android device with capabilities to detect fall accidents. They both rely on accelerometer data from the device as a means of detecting a fall but the differ significantly in how they use that data. 
	
	\subsubsection{Yildirim et al.}
	Yildrim et al. \cite{int_journ} uses a simple threshold-based algorithm to detect falls. When an acceleration-peak exceeding a threshold value, followed by a drop in acceleration below another threshold value has occurred within a limited time window, their application flags the event a possible fall and presents a user interface. This user interface lets the user discard the detected fall if it was a false alarm. If the user does not discard the detected fall, the application will send an SMS to predefined contacts, informing them of the event. 
	
	They tested the accuracy of their algorithm, with regards to distinguish an actual fall from other activities of daily living in terms of \textit{False positives} and \textit{false negatives}. In their tests, they used a total of five people, testing different scenarios five times each, the scenarios were:
	
	\begin{itemize}
		\item Falling
		\item Walking
		\item Sitting
		\item Jumping
		\item Lying
		\item Climbing stairs
	\end{itemize}
	
	The result shows that the number of \textit{false positives} were 9/25 on the falls scenario, and the number of \textit{false positives} were 7/25 on the jumping scenario. This means that their algorithm missed 9 out of 25 actual falls, and falsely flagged 7 out of 25 jumps as falls. In all other scenarios the number of \textit{false negatives/false positives} was zero. They conclude by saying that their algorithm had a hard time distinguishing between falling and jumping, but performed good in the other scenarios. 
	
	
	\subsubsection{Abbate et al.}
	Abbate et al. uses a significantly more sophisticated approach to detect and distinguish fall from activities of daily living. Their work involves a data buffer that continuously keeps the last few seconds of user movement activity in memory. It also includes a finite state machine as a first stop to detect a potential fall event. The state machine utilizes threshold values to establish when an impact is present and filters out the lions share of most ADL:s. User activity needs to follow a specific pattern in order to pass the state machine. Should the activity pass this first barrier, the data buffer is sent in to what they refer to as a \textit{feature Extractor}. The feature extractor examines the data in the buffer and extracts specific features of the data set such as the time and duration of the impact peak to mention just one. A total of eight features are then extracted and fed in to a neural network for classification  (\textit{The eight features are more thoroughly described in section 1.1.2 }). The neural network has a total of four output classes:

	\begin{itemize}
		\item Falls
		\item Jump/Run/Walk
		\item Hitting sensor
		\item Sitting/Lying
	\end{itemize}

	The output of the neural network is a vector of independent probabilities [\textit{0, 1}] that the classified event belongs to each of the four classes. If the probability of the falls class exceed all the other classes, the event is considered as a fall accident and an alarm is presented on screen. The user can thus, discard the alarm if it was false, or the alarm will be sent to a number of contacts o a contact list. 

	The evaluation of their neural network model shows a 100\% success rate in classifying events correctly. However, they used the same set of data to train their neural network as they did to evaluate and cross-validate it, which tends to yield higher a evaluation score. Further, from having put their application in the hands of three test persons, who used the application in an everyday fashion, excluding falling, for three days, they concluded that no false positives were alerted. This measurement is good for evaluating the discernment of false positives, but it says nothing about the implementations ability to not discard a real fall accident as well. 
	
	\subsubsection{Existing application: FallSafety}
	
	There already exists several applications for fall detection on the market. The best one that we have found is called \textit{FallSafety}. This application allows a user to register contact information to relatives and start protection mode. In this protection mode the application listens for falls and if a fall would be detected the application can send an email or SMS to the registered contacts. This is very similar to the application that we will create, but we know nothing about the internals of FallSafety. We can however use this application as a comparison when evaluating our application.
	
	\subsection{Approach by Yildirim et al.}
	Yildirim et al. takes a general approach to describe the character of several motional types \cite{int_journ}. In their research, they measured the response from a LSM330DLC acceleration sensor located in an Android device. Their approach uses a threshold value to indicate whether the acceleration vector exceeds the allowed limit for a crash. The blue, red and green lines corresponds to the acceleration on any of the three perpendicular axis \textit{X}, \textit{Y} and \textit{Z} shown in figure \ref{fig:XYZ-Axis}.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=8cm]{../img/accelerometer-axis.jpg} }}%
		\caption{The X, Y and Z axis af a smartphone device}%
		\label{fig:XYZ-Axis}% 
	\end{figure}
	
	This measurement shows that falling, is indicated by a significant drop in acceleration towards the earth's gravitational pull, signaling that the device is moving towards a free fall state, see figure \ref{fig:Pattern-Falling}. This drop is then followed by an acceleration spike as the device hits the ground. If a person were to get seriously injured due to a fall s/he would usually remain still on the ground for a period of time. Acceleration would thus gradually go back to the normal \textit{1g} indicated by the flat line after the peak. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=8cm]{../img/Falling.png} }}%
		\caption{The typical pattern of falling}%
		\label{fig:Pattern-Falling}%
	\end{figure}
	
	
	Walking shows a completely different pattern. As can be seen in figure \ref{fig:Pattern-Walking}, the changes in acceleration are not rapid like in the previous example. They are also repetitive, meaning that there is no longer period of non-movements after any of the peaks. The peaks themselves are also less significant than in the case of falling shown above. This implies that walking is easily distinguished from falling.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=8cm]{../img/Walking.png} }}%
		\caption{The typical pattern of walking}%
		\label{fig:Pattern-Walking}%
	\end{figure}
	
	
	 Sitting down on a surface shows a similar pattern to falling with regards to a sudden drop in acceleration followed by a rapid spike and a longer period of non-movement, see figure \ref{fig:Pattern-Sittin}. The magnitude of these values are however far less than in the case of a fall and should thus be easy to single out. When a person sits down, s/he usually makes a soft movement towards the surface, which is matched by the lesser accelerational magnitude in all three directions \textit{X, Y} and \textit{Z}.
	 
	 \begin{figure}[H]
	 	\centering
	 	\subfloat{{\includegraphics[width=8cm]{../img/Sitting_down.png} }}%
	 	\caption{The typical pattern of sitting down}%
	 	\label{fig:Pattern-Sittin}%
	 \end{figure}
	
	Jumping is according to Yildirim et al. the hardest pattern to distinguish from a fall, see figure \ref{fig:Pattern-Jumping}. The pattern has a sudden drop in acceleration, followed by a large spike as the jumper crouches and accelerates upwards. After this comes yet another sudden drop in acceleration as the jumper reaches the maximum altitude and starts falling back to earth again. From this part the pattern is almost identical to that of falling. When the jumper falls back to earth, the acceleration drops and then causes another huge spike as s/he hits the ground. When thinking about it, jumping and falling are in fact similar motional types, with the difference that jumping is prefixed by a drop and a spike before becoming an actual fall. The main challenge here is thus to be able to differentiate this from an unintentional falling accident.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=8cm]{../img/Jumping.png} }}%
		\caption{The typical pattern of jumping}%
		\label{fig:Pattern-Jumping}%
	\end{figure}
	
	\subsection{Approach by Abbate et al.}
	Abbate et al. takes the above approach further by trying to establish a more sophisticated algorithm that utilizes more than merely just an acceleration vector compared to a threshold value to distinguish a fall like motional pattern from other types of ADL. Their thesis rely on several guidelines which among other include: 
	\begin{itemize} 
		\item "Detection of falls should be carried out using only acceleration-based information. Previous work demonstrated that acceleration is the most reliable information that can be used in detecting a fall, while other kinematic data, such as angular velocity, is less relevant." \cite[p~3]{piza_uni}
		
		\item "Still for usability reasons, the fall detection algorithm should work only with the magnitude of acceleration and not with the values along each of the three accelerometer‚Äôs axes, as this, again, would require a known and fixed orientation of the device with respect to the user‚Äôs body." \cite[p~3]{piza_uni}
	\end{itemize}
	
	The latter identifies the importance of calculating the resultant vector that comprises the sum of all three vectors \textit{X}, \textit{Y} and \textit{Z}. Vector length can be calculated in accordance to equation \ref{vectorlength}.
	
	\begin{equation}
	\label{vectorlength}
	|\vec{v}|=\sqrt{x^2+y^2+z^2}
	\end{equation}
	
	This vector is the overall acceleration imposed on the device (and possibly the person carrying it). They proceed by defining a \textit{fall-like-event} as "an acceleration greater than \textit{3g} followed by a period of \textit{2500ms} without further peaks exceeding the threshold." \cite[p~5]{piza_uni}. They further argue that the threshold \textit{3g} is chosen since it has been widely used in other types of fall detection systems. According to their experiments, a post-fall event usually means that the body of the unfortunate becomes lying still on the ground after a period of about \textit{1000ms}. This interval, which resides within the \textit{2500ms} interval prior to fall detection, is often due to minor peaks following the main impact as a result of that parts of the body/device may hit the ground at different times. 
	
	Abbate et al. tries to establish their algorithm using a \textit{finite-state-machine} with five distinct states, seen in figure \ref{fig:Abbate-state-machine}.
	
	\begin{itemize}
		\item The \textit{sampling} state is the normal state that the process resides in until \textit{threshold-peak} is detected.
		
		\item When a peak occurs that exceeds the threshold value of \textit{3g} the state is transferred to \textit{post peak}. Well in this state, a bouncing timer of \textit{1000 ms} is started. If another peak exceeding the threshold occurs during this time, bouncing timer is reset, otherwise the state machine moves on to the \textit{post fall} state when the timer fires.
		
		\item In the \textit{post fall state} no peaks exceeding the threshold are allowed during \textit{1500 ms}, or the system goes back to the \textit{post peak} state. The purpose if this state is to check for activity (movement). If another peak occurs, it signals that either is the presumed fall not finished, or the subject is moving and this should not regarded as a fall. 
		
		\item When the \textit{post fall timer} fires after 1500 ms, the state machine moves on to the \textit{activity test} state. In this test, if movement exceeding certain thresholds are detected, it once again signals that activity is found and that this was indeed not an actual fall but rather a result of ADL. 
		
	\end{itemize}  
	
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=8cm]{../img/Abbatea_finite_state_machine.png}}}%
		\caption{The sensing process discussed in Abbate et al.}%
		\label{fig:abbatea-state-machine}%
	\end{figure}
	
	
	
	If a fall like event has passed through the  \textit{activity test} (the last state in the state machine), it is fed through a feature extractor, which analyses the data and extracts specific and predefined features of the data set. The features represent certain particular types of data that can be found by analysing the wave form collected when sampling the accelerometer. Before describing the features they defined 3 properties:
	\begin{itemize}
		\item \textit{Peak time} - The time of the detected peak (which is followed by \textit{2500 ms} without further peaks).
		\item \textit{Impact end} - The time of the last impact exceeding \textit{1,5 g} after \textit{peak time + 1000 ms}
		\item  \textit{Impact start} - The time of the last sample below \textit{0,8 g} before \textit{peak time} or \textit{peak time} if not found. 
	\end{itemize}
	They used a total of 8 features:
	
	\begin{itemize}
		\item \textit{Average absolute Acceleration Magnitude Variation} - The average magnitude of the acceleration samples, collected in the time window (\textit{win}) of \textit{1000 ms} centred at the middle between \textit{impact start} and \textit{impact end}, can be calculated according to the formula in \ref{fig:aamv-formula}. 
		
		
		\begin{figure}[H]
			\centering
			\subfloat{{\includegraphics[width=8cm]{../img/AAMV_formula.png}}}%
			\caption{The formula for calculating AAMV \cite{piza_uni}}%
			\label{fig:aamv-formula}%
		\end{figure}
		
		\item \textit{Impact Duration Index} - The duration of the impact peak, exceeding the threshold.
		\item \textit{Maximum Peak Index} - The highest value of the peak found in the interval [\textit{impact start}, \textit{impact end}]
		
		\item \textit{Minimum Valley Index} - The lowest value of acceleration magnitude found in the interval [\textit{impact start} - 500 ms, \textit{impact end}]
		
		\item \textit{Peak duration index} - The duration represented by \textit{impact end - impact start}
		\item \textit{Activity Ratio Index} - The number of samples in a \textit{700 ms} time window centred between \textit{impact start} and \textit{impact end} that are not in [\textit{0.85g, 1.3g}] divided by the number of total number of samples in that time window.
		
		\item{Free Fall Index} - The average acceleration magnitude found in an interval up to \textit{200 ms} before \textit{peak time} till up to \textit{400 ms} before peak time.
		
		\item{Step count index} - The amount of valleys and peaks in the interval [\textit{peak time - 2200 ms}, \textit{peak time}]
	\end{itemize}
	
	These extracted features are then fed in to a neural network with eight inputs and four neurons in a single hidden layer (\textit{neural network are thoroughly described in this free on-line book}  \cite{neural_networks}). The output layer consists of the four classes (\textit{Falls, Sitting/Lying, Jump/Run/Walk, Hitting sensor}). The network outpost the estimated probability of the event on all four classes and if the probability for the \textit{Falls}  class exceeds all other probabilities, the event is classified as a fall.
	
	\subsection{Machine learning}
	Machine learning is a field within computer science dealing with methods to get computers to learn from data without specifically being programmed to do so in advance. In its essence, this field of research is a mixture between statistical analysis, artificial intelligence and pattern recognition. Machine learning has many sub-fields and methods, one of them is neural networks. 
	
	\subsubsection{Structure of neural networks}
	A neural network tries to mimic the human brains structure of interconnected nodes called neurons in order to make a decision based on some input \cite{neural_networks}. A common user case for a neural network is that of classification, which means to classify something based on some input. An example could be classifying image content. Using an image containing a dog as input, the out put would thus ideally be "Dog". The network is usually structured to have an input layer, an output layer and one or several layers in between called "hidden layers". In each layer (besides the input layer) there are usually several neurons, whom each takes their input from all the neurons in the previous layer, and each send their output to all neurons in the successive layer. 
	
	The input layer is usually a (multidimensional) vector containing the data (numerical values) to examine. In the case of classification, the output layer then has as many neurons as there are possible classes. The output is thus yet another vector with the independent probability coherence for the input to each of the classes, or in the case of one-hot-classification, a binary representation in a vector with the decided class set to one, and the other classes set to zero. 
	
	Between the neurons in each layer are connections. Every single connection has a weight which is determined when training the neural network. Each neuron also have an activation function and a bias.
	
	\newpage
	
	The output of each neuron is calculated according to formula \ref{neuron-formula}:
	
	\begin{equation}
	\label{neuron-formula}
	f((\sum_{k=1}^{n} X_{k} * W_{k}) + b)
	\end{equation}
	
	where:
	
	
	\begin{itemize}
		\item $n$ is the number of inputs to the neuron
		\item $X_{k}$ is the input from a single neuron in the previous layer
		\item $W_{k}$ is the weight of a single connection
		\item $b$ is the bias of the neuron
		\item $f$ is the activation function of the neuron (for example sigmoid).
	\end{itemize}
	
	
	There are many activation functions to choose from but a common one is the "sigmoid" function seen i \ref{sigmoid} \cite{towards-data-sci}:
	
	\begin{equation}
	\label{sigmoid}
	f(x)=1/1 + e^{-x}
	\end{equation}
	
	The purpose of the activation function is to map the sum of a neuron's inputs to a value in a distinct range \textit{(0, 1), (-1, 1) etc.} in order to prepare it as input to the neurons in the next layer \cite{towards-data-sci}. 
	
	Figure \ref{fig:neural-network-overview} illustrates a general design of a simple, densely connected, feed-forward neural network. The network has a one-dimensional vector of length three as input, and a one-dimensional vector of length two as output representing probabilities of the two output-classes. Each neuron in a previous layer is connected to all a neurons in the successive layer, and each single connection has it¬¥s own weight. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=12cm]{../img/neural-network-overview.png} }}%
		\caption{An example of a simple neural network with 3 features in the input layer, two neurons in the output layer and a single hidden layer with 4 neurons.}%
		\label{fig:neural-network-overview}%
	\end{figure} 
	
	\subsubsection{Training neural networks}
	When training a neural network, the individual weights are set to random values initially. All labelled training data is then fed into the network, this is called \textit{feed-forward}. At the end of each data sample feed, the output probability is compared to that particular sample's class using a loss function, the weight are then adjusted to better be able to predict the class and the process repeats. The adjustment of weights is called \textit{back-propagation}. A run through of all the samples in the training data set (feed-forward) followed by equally as many adjustments to weights (back-propagation) is called an \textit{epoch}. Training a neural network usually involves many epochs. When the network has been trained, the accuracy can be measured, using a test data set with unlabeled data \cite{neural_networks}.
	
	
	\newpage
	\section{Methods and Methodology} \label{section:methods}
	
	This chapter describes the research strategy and the methodologies used in the study, and how each methodology contributes to answering the research questions.
	
	\subsection{Research Strategy}
	
	This section describes research methods in general, and how the methods are adopted in this thesis.
	
	\subsubsection{Quantitative and qualitative methods}
	
	Research methods are often divided in two classes, \textit{quantitative} and \textit{qualitative} methods.
	
	\textit{Quantitative} methods are distinguished by the use of measurable data \cite[p~54]{borrego}. This data can be numbers such as a measured distance, collected statistics, the outcome of an experiment, etc. Quantitative methods are a way for the researcher to take an objective approach.
	
	\textit{Qualitative} methods on the other hand, is characterized by the collection of textual data \cite[p~55]{borrego}. This data can be interviews, surveys, observations, etc. Qualitative methods emphasis the importance of context in which the study is performed.
	
	\subsubsection{Inductive and deductive methods}
	
	An \textit{inductive} research method can be viewed as a bottom-up approach, where the researcher begins by collecting data that is relevant to the subject. After that, the data is analyzed, with the intention to develop a theory that explains the patterns observed in the data.
	
	A \textit{deductive} method is a top-down approach, where a hypothesis is developed from existing theory. After the hypothesis is formulated, it is tested with the intent to confirm or falsify it.
	
	\subsubsection{Case studies}
	
	Case studies makes it possible for a researcher to closely examine a specific phenomenon. They can be explorative, explanatory or descriptive \cite[p~4]{yin}. A case study is often limited to a small number of people or a small geographic area to perform an in-depth examination, and can be a good research method for answering questions starting with "how" or "why".
	
	\subsubsection{Adopted Methods}
	
	For our research, a qualitative approach seems to be the most appropriate. It will be a case study that explores the possibility of creating a fall detection application, answering how this should be done. The research will be deductive, starting with the hypothesis that this kind of application can be created, trying to confirm the hypothesis. 
	
	In order to give an answer to the first question of our problem statement, RQ1, we need to solve a number of sub problems. The first problem is to find a suitable algorithm that can achieve accurate fall detection, since without a good algorithm it will be impossible to make a useful implementation. The second problem is to implement this algorithm in a mobile application using the sensors available in smartphones. This could be troublesome if the algorithm expects better sensors than what is available in the smartphone. The third sub problem is to evaluate the implementation. We will evaluate the accuracy of the fall detection, that is how many of the detected falls are actual falls, and how many actual falls are not detected. Another part of the evaluation will be to evaluate the application's impact on battery life. For these sub problems we formulate specific questions that we will need to answer in order to answer the problem statement.
	
	\begin{itemize}
		\item What algorithm should be used to accurately detect a fall?
		\item How can technology available in smartphones be used to implement an algorithm for fall detection?
		\item How can accuracy and performance be improved when implementing fall detection in a smartphone?
	\end{itemize}
	
	\parag{Literature Study}
	The literature study that we will perform will focus on finding an algorithm that can be used to accurately detect a fall. Performing a literature study will give us a wider understanding of the subject as well as a good starting point for the study. The result of the literature study will show which algorithm for fall detection that would be proposed by previous studies. We will use this algorithm as a starting point for our own implementation, where we will try to improve the algorithm. The outcome of the literature study is presented in the theoretical background.
	
	\parag{Case Study: Developing a mobile application}
	The second part of our research will be a case study where we implement a fall detection system. We will use the algorithm found in the literature study and implement it for Android and iOS using the sensors available in the smartphones. Developing the application will give us an opportunity to test the algorithm on real devices, and a platform where we can experiment in order to improve the algorithm. The result of the development will give us the ability to answer how technology available in smartphones can be used to implement the algorithm found in the literature study.
	
	\parag{Evaluating the implemented mobile application}
	The third part of our research will be to evaluate the implemented algorithm by performing experiments where the mobile application is used to detect falls. This evaluation will focus on how accurate the application is, but also on how it affects the battery life of the device.
	
	\subsubsection{Research Process}
	
	In this thesis project, the work is divided in phases as seen in figure \ref{fig:research-process}. The first phase, the problem statement serves to formulate the problem that the thesis will try to solve. The second phase is the literature study, where reports from earlier studies are collected and read to give us a deeper understanding of the subject. The third phase is the analysis phase, where the results of the literature study is analysed in order to find an algorithm that will be suitable as a starting point for the application. After the analysis phase the case study begins, where we implement the mobile application. After the case study phase the evaluation phase starts, where the final version of the application developed in the case study is evaluated. After that, the conclusion phase starts, where the results are summarized and conclusions formulated. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=14cm]{../img/method-phases.png} }}%
		\caption{The different phases in the thesis project}%
		\label{fig:research-process}%
	\end{figure}
	
	\subsection{Design and Implementation of Application}
	
	To develop the mobile application we will use an iterative development method. By using an iterative method we will make sure that the most important features are developed first, since we will develop the most important features in the first iteration and only after that continue with the less important features. This will help us  minimize the risks in the project. If the project would suffer from lack of time, we would at least have developed the most important features already. The project method that we will be using will be similar to Scrum, although since we are only two developers, the team involved in development will be much smaller than the typical agile team.
	
	We will divide the work in such a way that one of us will develop the Android implementation, and the other will develop the iOS implementation. By dividing the work in this fashion we can implement similar features in both applications without the risk of writing conflicting code. Another reason for dividing the work is that it will help us to have equal focus on both the Android and iOS implementation.
	
	\subsubsection{Development Process}
	
	The development process will follow the outline in figure \ref{fig:development}. The process will start with design, where an initial version of the application is designed, with only a limited set of features. We will then implement those features, and then evaluate the developed features and the application. After that we will go back to development, and based on the outcome of the development we will either start over, or continue with new features.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=14cm]{../img/method-development.png} }}%
		\caption{The application development process}%
		\label{fig:development}%
	\end{figure}
	
	\subsubsection{Development Environment}
	
	The application will be divided in two implementations, one for Android and one for iOS. The development environment will be slightly different for Android and iOS. 
	
	\parag{Android}
	The Android application will be developed using Android Studio, since it is the official development environment.
	
	\parag{iOS}
	The iOS application will be partly developed in Xcode, since it is the official IDE, and partly in Jetbrains AppCode since it is superior to Xcode when it comes to re-factoring code, code completion, etc. Xcode will be used for building graphical interfaces, but the coding will be done in AppCode.
	
	\subsection{Evaluation Methods}
	
	This section describes how the developed application will be evaluated. Evaluating the application is important since it will show how well it solves the problem.
	
	\subsubsection{Evaluating accuracy}
	
	The first step in the evaluation of the application will be to perform crash tests where we measure how well the application detects a fall, by dropping a mobile phone running the application several times from a height that we define as a fall and count the number of reported falls. The different heights that we have chosen are 3 m, 1.5 m, and 1 m. Dropping the phone from 3 m is supposed to simulate falling from a ladder or similar, 1.5 m simulates falling from a stool or similar, with the phone in the pocket and 1 m simulates a fall from standing on the ground.
	
	Another test will be to walk for a short distance and then immediately drop the phone. This is supposed to simulate falling while walking. The test will include walking a distance of 10 m and then dropping the phone from a height of 1 m.
	
	Yet another test will be to perform daily activities that can trigger a fall detection system, even though it is not a fall. Theses activities can be running, or walking with the phone in the pocket. A good fall detection software will not report many of these as falls.
	
	We will perform each test 10 times each for Android and 10 times each for iOS. The tests that we will perform are the following:
	
	\begin{enumerate}
		\item Drop the phone from a height of 3 m
		\item Drop the phone from a height of 1.5 m
		\item Drop the phone from a height of 1 m
		\item Walk 10 m while carrying the phone, and drop the phone from a height of 1 m
		\item Run 10 m while carrying the phone in the pocket, and stand still for 5 s afterwards
		\item Walk 10 m while carrying the phone in the pocket, and stand still for 5 s afterwards
		\item Jump with the phone in the pocket, and stand still for 5 s afterwards
	\end{enumerate}
	
	\subsubsection{Evaluating battery life}
	
	To evaluate how the application affects the battery life of the mobile phone, we will use the native functionality in the operating system available on Android and iOS respectively to measure the specific applications power consumption.
	In combination with this, we will also perform tests where we run the application for a certain amount of time and note how much battery life is left and compare this value with the percentage left after not running the application for the same amount of time.
	
	\newpage
	\section{Fall Detection Application: Design} \label{section:application-design}
	
	This section describes the design of the fall detection application.
	
	\subsection{Architecture outline}
	The overall architecture of the application consists of several steps as visualized in figure \ref{fig:arch-outline}. All readings from the accelerometer is continuously pushed to a ring buffer.	This ring buffer holds the last 8 seconds of accelerometer data. On top of this, a \textit{Finite State Machine} is used as a first barrier to filter out the most common movements of the device. If a fall-like event were to manipulate the state machine into its final state, the ring buffer is transferred over to a \textit{Feature Extractor}. In this step, the buffer is analyzed and a total of 8 "features" are extracted (as similar to the Abbate et al. approach). These features represent important aspects of the movement of the device for the last 8 seconds. The 8 features are then put inside a data-object and fed into a \textit{Classification Engine} which consists of a neural network. This classification engine have the responsibility to classify the event based on the given features. The output classes of the neural network are: \textit{Fall}, \textit{Jump} and \textit{Run/Walk}. The neural network calculates the independent probability of the event's belonging to each of the three classes. If the probability of the event belonging to the \textit{Fall} class exceeds the other two, the event is considered a fall. 
	
	In the case of an event being classified as a fall, the application will present a screen along with a sonic alarm signal. The user will then have 45 seconds to discard the event or a message will be sent to a set of predefined contacts, notifying them about what¬¥s happened.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=14cm]{../img/architecture-outline.png} }}%
		\caption{Outline of the fall detection application}%
		\label{fig:arch-outline}% 
	\end{figure}
	
	\subsection{Accelerometer Data}
	The accelerometer is the sensor used for fall detection. Using the accelerometer on the Android and iOS system is similar. Updates from the accelerometer are pushed to listening code that acts upon those updates. Updates come in the form of an data-object containing information about the device's acceleration on all three axes (\textit{X}, \textit{Y} and \textit{Z}) at that moment in time. The accelerometer's update frequency is configurable on both Android and iOS devices and we chose an update frequency of \textit{50 Hz}, since it provides a reasonable balance between accuracy in measurements and battery consumption. 
	
	On each update, the resultant vector is calculated according to formula \ref{vectorlength} and the result is fed to both the ring buffer and the state machine.
	
	\subsection{Ring Buffer}
	
	A ring buffer is used to hold the last 8 seconds of data recorded by the accelerometer. Initially the ring buffer is empty, but for each accelerometer update the ring buffer is called with the accelerometer vector length as input. Before the ring buffer is full it simply saves the data. When the ring buffer is filled up, it overwrites the data in FIFO order so that it keeps the most recent data in the buffer and the oldest data is removed. With our configuration, the ring buffer has a fixed length of \(50 Hz * 8s = 400\) samples.
	
	\subsection{State Machine} \label{section:state-machine}
	
	For basic fall detection, a finite-state machine were used, see figure \ref{fig:state-machine}. The purpose of the state machine is to filter out possible falls that should be analyzed. The length of the resultant vector \textit{a}, coming from the accelerometer is fed as input to the state machine. The possible values for this input are in the interval \( [0, \infty) \), since vector length cannot be negative. The state machine reads the accelerometer vector length \textit{a} and the time since the machine entered the current state \textit{t}, and changes state based on different conditions for each state. If the state machine would reach its final state, this would mean that a potential fall has been detected.
	
	The thresholds used for the accelerometer input can be seen in figure \ref{fig:thresholds} and are defined as:
	
	\begin{itemize}
		\item Impact Threshold, \textit{IT}
		\item Upper Motionless Threshold, \textit{UMT}
		\item Lower Motionless Threshold, \textit{LMT}
	\end{itemize}
	
	The upper motionless threshold is 1.5 g, the lower motionless threshold is 0.5g, and the impact thresholds are different for Android and iOS. The impact threshold is 2.5g for Android and 4g for iOS.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[scale=0.8]{../img/thresholds.png} }}%
		\caption{Visualization of the defined thresholds used by the state machine.}%
		\label{fig:thresholds}%
	\end{figure}
	
	The impact threshold is used to detect impacts. Peaks that have values in the interval
	\( [IT, \infty) \) are possible impact peaks. 
	
	The interval \( (UMT, IT) \) is defined as motion, but not impact. This kind of motion can be walking or similar, which should not be detected as a fall.
	
	The interval \( [LMT, UMT] \) is the motionless interval. This interval is what we define as motionless.
	
	The interval \( [0, LMT) \) are the free falling interval. According to our definition, values in this interval shows that the device is falling. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=16cm]{../img/state-machine-3.png} }}%
		\caption{Fall detection state machine}%
		\label{fig:state-machine}%
	\end{figure}

	Figure \ref{fig:fall-data-state-machine} shows a visualization of the state machine in action. The time periods for the different states are highlighted with the same colors as in figure \ref{fig:state-machine}. In the figure, you can see how the accelerometer vector length \textit{a} varies over time, and how the state machine passes through the different states. The different thresholds \textit{IT}, \textit{UMT} and \textit{LMT} are also shown with line representations. The figure shows that when the accelerometer data drops below \textit{LMT} the state machine goes to the state called \textit{Falling}. When the data goes over that threshold again the state machine is in the \textit{Post falling} state for a short time. When the accelerometer data goes above \textit{IT} the state machine enters the \textit{Impact} state, and roughly 2 s later it enters the \textit{Motionless} state. The accelerometer data is in the interval \([LMT, UMT]\) for an additional 2 s and after that the state machine is in the \textit{Fall detected} state.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-state-machine.png} }}%
		\caption{Visualization of how the state machine passes through the different states during a potential fall, along with the acceleration magnitude. The colors of the different states correspond to the colors of the states in figure \ref{fig:state-machine}.}%
		\label{fig:fall-data-state-machine}%
	\end{figure}
	
	\subsubsection{Normal state}
	
	The initial state, when the state machine starts, is the normal state. If the length of the accelerometer resultant vector \textit{a} drops below the lower motionless threshold, a transition is made to the falling state.
	
	\subsubsection{Falling state}
	
	The falling state represents that the phone is falling freely, and it should have an acceleration close to zero, or at least under the lower motionless threshold. If the accelerometer vector length exceeds the lower motionless threshold but not the impact threshold, a transition is made to the post falling state. If the accelerometer vector length exceeds the impact threshold a transition is made to the impact state.
	
	\subsubsection{Post falling state}
	
	The post falling state is a state between the falling state and the impact state. It exists to allow a slight lag between the free falling and the impact. If the accelerometer vector length exceeds the impact threshold the machine enters the impact state. If the time since the machine entered the current state exceeds the time limit 0.1 s, a transition is made back to the normal state. This is because no impact occurred in the allowed time window.
	
	\subsubsection{Impact state}
	
	The impact state represents that an impact has been detected. In this state anything is allowed to happen under a time limit. If the accelerometer vector length exceeds the impact threshold, a transition back to the impact state is made to reset the timer keeping track of the time since the state machine entered the current state. If the timer value exceeds the 2 s threshold, a transition is made to the motionless state.
	
	\subsubsection{Motionless state}
	
	The motionless state exists to make sure that the phone is motionless after the fall. If the accelerometer vector length exceeds the upper motionless threshold, the machine goes back to the normal state. If the vector length drops below the lower motionless threshold, a transition is made to the falling state. If that does not happen and instead the timer exceeds 2 s, the machine enters the fall detected state.
	
	\subsubsection{Fall detected state}
	
	In the fall detected state, a potential fall has been detected. The machine takes action to inform the rest of the application that the data in the ring buffer should be analyzed to see if this was an actual fall.
	
	\subsection{Feature Extractor} \label{section:feature-extractor}
	
	The purpose of the feature extractor is to take the data in the ring buffer and extract 8 defined features from it. The 8 features will then be used in the neural network. The features are similar to the features defined by Abbate et al. \cite{piza_uni}, but redefined. The data coming from the ring buffer and the features defined by the feature extractor is visualized for one example case in \ref{fig:fall-data-example}. In the figure, one recorded potential fall is graphed. On the vertical axis is the acceleration vector length \textit{a} and on the horizontal axis is time measured in milliseconds. The different thresholds \textit{Impact Threshold}, \textit{Upper Motionless Threshold} and \textit{Lower Motionless Threshold} are shown with line representations. The top of the figure contains some information about this potential fall. It states that the device is an iPhone, meaning that this particular case was recorded on an iPhone. It also prints the operating system of the phone used for recording, and the date. The data shows the \textit{impact start} and \textit{impact end} in milliseconds, stating where the impact starts and end. After that comes the eight features of the fall, \textit{Average acceleration variation}, \textit{Impact duration}, \textit{Impact peak value}, \textit{Impact peak duration}, \textit{Longest valley value}, \textit{Longest valley duration}, \textit{Number of peaks prior to impact} and \textit{Number of valleys prior to impact}. It also states the classification type that was entered when the potential fall was recorded. In this case, it was an actual fall. The classification number is the integer representation of that classification. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-example.png} }}%
		\caption{Recorded data from dropping the phone. Each point on the graph represents one sample in the ring buffer. The values found by the feature extractor can be seen at the top.}%
		\label{fig:fall-data-example}%
	\end{figure}
	
	\subsubsection{Average acceleration variation}
	
	The first feature that the extractor should find is the average acceleration variation. This feature is calculated using the formula in figure \ref{fig:aamv-formula} and is supposed to measure how much the acceleration varies after the initial impact peak. Figures \ref{fig:fall-data-run-ios} and \ref{fig:fall-data-run-android} shows examples of where this variation is significant, as compared to figures \ref{fig:fall-data-fall-ios} and \ref{fig:fall-data-fall-android} where the variation is small. Because the difference is so significant between the different classification types it is a good feature to measure. A small variation means that the body exposed to the fall came to a quick stop after the impact. A large variation on the other hand means that there was some smaller impact or shaking after the impact. This indicates that the body did not come to a quick stop.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-run-ios.png} }}%
		\caption{Recorded data on iOS while running. The acceleration variation after the peak is significant.}%
		\label{fig:fall-data-run-ios}%
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-run-android.png} }}%
		\caption{Recorded data on Android while running. The acceleration variation after the peak is significant.}%
		\label{fig:fall-data-run-android}%
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-fall-ios.png} }}%
		\caption{Recorded data on iOS for a fall. The acceleration variation after the peak is small.}%
		\label{fig:fall-data-fall-ios}%
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-fall-android.png} }}%
		\caption{Recorded data on Android for a fall. The acceleration variation after the peak is small.}%
		\label{fig:fall-data-fall-android}%
	\end{figure}
	
	\subsubsection{Impact duration}
	
	The impact duration is the time in milliseconds elapsed from the first sample of the impact peak exceeding the impact threshold to the last sample that is outside of the interval [Lower motionless threshold, Upper motionless threshold]. An example of impact duration is highlighted in figure \ref{fig:fall-data-impact-duration}. This feature is interpreted as the length in time of the actual impact. It measures how long time it took for the body to become motionless after the impact peak. This means that if a short impact duration is measured the body came to a quick stop, and in case of a long impact duration it took longer time for the body to stop.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-impact-duration-android-highlight.png} }}%
		\caption{Visualization of impact duration. The impact duration is highlighted in green. The impact start is around 3700 ms and impact end around 4080 ms, which gives an impact duration of \textit{4080 - 3700 = 380 ms}.}%
		\label{fig:fall-data-impact-duration}%
	\end{figure}
	
	\subsubsection{Impact peak value}
	
	The impact peak value is the highest value for acceleration vector length found on the last peak. The last peak is the peak that triggered the state machine. An example of impact peak value is highlighted in figure \ref{fig:fall-data-impact-peak}. This feature is equal to or at least proportional to the amount of g-forces that the body was exposed to during impact. A high value in impact peak means that it was probably a harder fall.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-impact-peak-highlight.png} }}%
		\caption{Visualization of impact peak value. This fall has a significant impact peak value of around \textit{8.6g}}%
		\label{fig:fall-data-impact-peak}%
	\end{figure}
	
	\subsubsection{Impact peak duration}
	
	The impact peak duration is the time in ms that the last peak exceeds the impact threshold. An example of this is shown in figure \ref{fig:fall-data-impact-peak-duration}. The impact peak measures for how long time the body were exposed to an acceleration exceeding the impact threshold. With impacts related to falling this time is probably rather short, at least if the body lands on a hard surface. If this time duration would be longer, it would suggest that the impact was actually more of a soft slowing down than an impact.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-impact-peak-duration-highlight.png} }}%
		\caption{Visualization of impact peak duration. The impact peak duration is highlighted in green.}%
		\label{fig:fall-data-impact-peak-duration}%
	\end{figure}
	
	\subsubsection{Longest valley value}
	
	The longest valley is the longest continuous time found where each sample is below the lower motionless threshold. The longest valley value is the lowest sampling value found during that time. An example of longest valley value is shown in figure \ref{fig:fall-data-longest-valley-value}. This feature measures the lowest amount of g-force found during the longest free falling period. A low value, close to zero, means that the body were indeed free falling. A higher value would imply that the body were never really free falling.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-longest-valley-value-highlight.png} }}%
		\caption{Visualization of longest valley value. The longest valley value is highlighted in green.}%
		\label{fig:fall-data-longest-valley-value}%
	\end{figure}
	
	\subsubsection{Longest valley duration}
	
	The longest valley duration is the duration of the longest continuous time found where each sample is below the lower motionless threshold, measured in milliseconds. The time period for longest valley duration is highlighted in figure \ref{fig:fall-data-longest-valley-duration}. This feature indicates for how long the body where free falling before the impact. A long time measured for longest valley duration means that the body where probably free falling for a long time before the impact. A shorter time means that the free falling phase where shorter.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-longest-valley-duration.png} }}%
		\caption{Visualization of longest valley duration. The longest valley duration is highlighted in green.}%
		\label{fig:fall-data-longest-valley-duration}%
	\end{figure}
	
	\subsubsection{Number of peaks prior to impact}
	
	The number of peaks prior to impact represents the number of continuous time intervals before the impact start, where each sample in the interval exceeds the impact threshold. Peaks prior to impact are highlighted in green in figure \ref{fig:fall-data-peaks-and-valleys}. Simply put, this feature measures how many times before the impact, the threshold is exceeded. This is supposed to relate to the number of steps taken by the user before the fall. A higher value means that the user may have been walking or running, while a low value means that the user where still before the fall.
	
	\subsubsection{Number of valleys prior to impact}
	
	The number of valleys prior to impact is similar to the number of peaks prior to impact, but it counts the number of valleys instead of peaks. The valleys are defined as the continuous time intervals where each sample in the interval is below the lower motionless threshold. The valleys prior to impact are highlighted in red in figure \ref{fig:fall-data-peaks-and-valleys}. Similar to measuring the number of peaks, this is also related to the number of steps taken by the user. According to our measurements, running typically produces one peak and one valley for each step. A low value for \textit{Number of valleys prior to impact} means that the user where probably still before the fall.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/fall-data-peaks-and-valleys.png} }}%
		\caption{Visualization of peaks and valleys prior to impact. The peaks are marked with green and the valleys are marked with red. In this example there are 4 peaks prior to impact, and 4 valleys prior to impact.}%
		\label{fig:fall-data-peaks-and-valleys}%
	\end{figure}
	
	
	 \subsection{Classification Engine}
	 
	The classification engine uses a neural network under the hood to make predictions on possible fall candidates. It accepts an object containing the eight features extracted from the feature extractor, and puts those features in a one dimensional array with each feature at a specified index. The array is then given to the machine learning model. The output from this model is another one dimensional array containing the predicted possibilities for each class respectively at specified indices. The classification engine then finds the highest prediction in the array and converts it to it¬¥s corresponding class type \textit{Fall, Run/Walk or Jump} and returns this value.
	 
	\subsubsection{Implementing a neural network}
	The implementation of the neural network consists of three steps. The first step is related to data collection. The second step involves designing the network in terms on layers and neurons, \textit{this will from now on be referenced as the model}, as well as fitting and evaluating the model to make as accurate predictions as possible. The final step using the model in the application and evaluate its accurateness in real world scenarios. The full process from data collection to final model can be seen in figure \ref{fig:training-model}.
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/training-model.png} }}%
		\caption{The process of collecting data and training the model}%
		\label{fig:training-model}%
	\end{figure}
	
	\subsubsection{Data collection}
	In order to collect motion data, we intercept every event that passed through our state-machine and following feature-extractor described in sections \ref{section:state-machine} and \ref{section:feature-extractor}. Thus, for all events that are recognized as a potential fall candidate, we have an object with its own set of the eight features described in section \ref{section:feature-extractor} as well as the original 400 sample long array of acceleration data collected from the accelerometer. The features are to be used when training the model and the array of data points is only used for visualization of the event on our graphical tool. Each event is labeled according to the class it belongs to: \textit{fall, run/walk or jump}. The last step is to save each event to a database. 
	
	When collecting data for the \textit{run/walk} and \textit{jump} classes, we placed the device in the trouser pocket (a normal place to keep the device in everyday life) and walked, ran and jumped respectively. Collecting data for the \textit{fall} class was done by letting the phone fall from different altitudes, ranging from 1.5 m up to 3 m, and landing on different natural surfaces. A series of events simulating falling while walking was also done by simply walking/running with the device and drop it to the ground mid walk.
	
	In total, 210 samples were collected, evenly distributed between the different classes and devices.
	
	\subsubsection{Designing a model}
	The neural network is built using \textit{Tensor Flow}, \textit{Keras} and the \textit{Python} programming language. After experimentation with the amount of hidden layers and neurons when training the model, we arrived at the conclusion that a single hidden layer with seven neurons yielded the best possible accuracy given our data set. The activation function is set to \textit{sigmoid} for the hidden layer as well as the output layer. The result is a neural network with eight inputs, one for each feature, and three outputs, one for each class. 
	
	\begin{figure}[H]
		\centering
		\subfloat{{\includegraphics[width=15cm]{../img/neural-network-model.png} }}%
		\caption{The neural network}%
		\label{fig:neural-network}%
	\end{figure}
	
	\subsubsection{Training the model}
	When training the model, we downloaded all the data samples from the database and printed them to a CSV-file using our standalone graphical utility tool. The dataset is then split up between training-set, and evaluation-set on a ratio of 9:1. The training set contains the labelled training data, whereas the evaluation-set contains unlabelled data for measurement and cross-validation. The network training program uses the commonly used feed-forward <-> back-propagation method \cite{neural_networks} to fit the model. 
	
	
	\subsubsection{Using the model}
	The trained and evaluated neural network are finally converted into two separate file formats that can be used natively in iOS and Android applications. The generated files are simply included in the mobile application project after what they can be used to make predictions on future real life events. The input to the models are a vector of length eight, containing the values of the eight features for an event extracted by the feature-extractor. The output is a vector of length three, containing the independent probabilities of class adherence for the same event. 
	
	In the final product, where data collection functionality is removed, it is the values in the output vector that are used to finally decide if an event are to be classified as a fall accident or not. If the probability that the event belongs to the fall-class exceeds the other two, the application flags the event as a fall and presents the discard screen to the user, otherwise, the event will be automatically discarded by the application. 
	
	
	\subsection{Comparison with the model developed by Abbate et al.}
	
	This section briefly discusses the differences in our model compared to the one used by Abbate et al.
	
	\subsubsection{Changes in the state machine}
	
	The work made by Abbatea et al. served as a good starting point for our research project, since their work is very similar to what we want to achieve. When reading their report we thought that their work could be improved on some points. One of them were the state machine. The state machine used by Abbatea et al., presented in figure \ref{fig:abbatea-state-machine}, were lacking a state for free falling, that is, when the acceleration magnitude drops below \textit{g}. Their report describes that their state machine had some trouble distinguishing from a real fall and simply hitting the sensor. These cases were later filtered out by their machine learning module, which were examining if the acceleration magnitude had dropped below \textit{g} or not. For this reason we though that it would be an improvement to detect the free falling in the state machine and filter out the cases that had no free fall before the impact. We did this by introducing a state called \textit{Falling} in which the acceleration magnitude must be lower than a certain threshold.
	
	\subsubsection{Using a neural network}
	
	Initially we had not intended to implement a machine learning model in the project, since we did not think that it would be much better than just using a state machine. But since Abbate et al. had used a neural network for their implementation we decided to give it a try. We defined the features that were fed into the neural network slightly different. The first main difference where that we did not include their \textit{Activity Ration Index} since the difference in value for that feature between the different classes were small. The other main difference were that we did not use their \textit{Step Count Index}, since we defined \textit{Number of peaks prior to impact} and \textit{Number of valleys prior to impact} instead, distinguishing from peaks and valleys instead of just counting steps. 
	
	After we had decided which features to extract we started to experiment with the neural network. We started out with the same neural network that they had used, with 8 inputs, 8 neurons and 4 output classes, but we fed the network with our 8 features instead of theirs. While experimenting with collecting data and training the model we realized that one of the 4 output classes, \textit{Hit device}, were never encountered. This is probably due to the difference in the state machine, indicating that our state machine had successfully filtered out that class before reaching the machine learning model. Since that class were never detected there were no need to keep it in the neural network, so we removed it.
	
	To see if the accuracy in the model could be improved while training, we experimented with adding additional layers of neurons. We tried to use 2, 3 or 4 layers of neurons instead of just one, but the experiments showed that the accuracy in the model decreased, for this reason we removed the additional layers and went back to a single layer of neurons.
	
	\subsection{Running the application in background}
	
	When implementing fall detection in a smartphone, it is important that the application can run in background mode. By background mode we hereby refer to when the app is not present on the screen. This means that the app is either behind another application when the user is using the device, or when the device itself is locked. Since the application is supposed to run for a long time, we cannot expect the user to have the application visible in foreground all the time. This turned out to be quite troublesome, at least in iOS. This section describes how this challenge were solved on the different platforms.
	
	\subsubsection{Android}
	
	In Android, it is possible to define a background task by creating a class that extends \texttt{android.app.Service}. We chose to create a Service that communicates with our state machine and classification engine, and if a fall is  detected the Service broadcasts the fall to any registered \\ \texttt{android.content.BroadcastReceiver}.
	
	\subsubsection{iOS}
	iOS is very strict with regards to allowing applications to do background processing , only a few types of background tasks are allowed such as playing audio, getting location updates or downloading content from the internet to mention some. However, by signing up for one of the allowed background modes, the app can be kept alive in the background and thus perform other tasks in the meantime such as sampling the accelerometer. Since location updates is needed to alert emergency contact about the users location in case of a fall accident, our choice of background mode is location services.
	
\subsection{Application user interface}
	
	Below is a rundown of the application user interface, only the most relevant view are shown.
	
	\begin{figure}[H]
		\begin{multicols}{2}
			\centering
			\includegraphics[width=6cm]{../img/screenshots/main-screen.jpg}\par 
			\includegraphics[width=6cm]{../img/screenshots/main-screen-android.png}\par 
		\end{multicols}
		\caption{The main interface of the application lets the user enable/disable fall detection as well as go to settings and toggle sonic alarm on/off. The iOS version is to the left, and Android to the right.}%
		\label{fig:main-screen}%
	\end{figure}
	
	\begin{figure}[H]
		\begin{multicols}{2}
			\centering
			\includegraphics[width=6cm]{../img/screenshots/settings-screen.jpg}\par 
			\includegraphics[width=6cm]{../img/screenshots/settings-screen-android.png}\par 
		\end{multicols}
		\caption{From the settings screen, the user can choose to view emergency contacts, his or hers profile and log out of the application. The iOS version is to the left, and Android to the right.}%
		\label{fig:settings-screen}%
	\end{figure}
	
	
	\begin{figure}[H]
		\begin{multicols}{2}
			\centering
			\includegraphics[width=6cm]{../img/screenshots/contacts-screen.jpg}\par 
			\includegraphics[width=6cm]{../img/screenshots/contacts-screen-android.png}\par 
		\end{multicols}
		\caption{The contacts screen displays all emergency contacts defined by the user. The user may also add a new contact by tapping the + sign. The iOS version is to the left, and Android to the right.}%
		\label{fig:contacts-screen}%
	\end{figure}
	
	\begin{figure}[H]
		\begin{multicols}{2}
			\centering
			\includegraphics[width=6cm]{../img/screenshots/contacts-detail-screen.jpg}\par 
			\includegraphics[width=6cm]{../img/screenshots/contacts-detail-screen-android.png}\par 
		\end{multicols}
		\caption{The contact detail view let the user view contact details as well as edit them by pressing the edit button. The iOS version is to the left, and Android to the right.}%
		\label{fig:contacts-detail-screen}%	
	\end{figure}
	
	\begin{figure}[H]
		\begin{multicols}{2}
			\centering
			\includegraphics[width=6cm]{../img/screenshots/alarm-screen.jpg}\par 
			\includegraphics[width=6cm]{../img/screenshots/alarm-screen-android.png}\par 
		\end{multicols}
		\caption{The alarm screen is shown when the app detects a fall, the user now has 45 seconds to discard the event by pressing "I'm OK", or an email containing information and coordinates will be sent to the users emergency contacts when the timer fires. The iOS version is to the left, and Android to the right.}%
		\label{fig:alarm-screen}%
	\end{figure}
	
	
	\newpage
	
	\section{Fall Detection Application: Evaluation} \label{section:application-evaluation}
		Evaluation of the application was done by conducting a series of test in a real-world setting. The test aims to evaluate two things, the accurateness of the fall detection system, and the impact on battery this system implies. All tests scenarios were identical on the iOS and Android platform. 
	
	In the case of accurateness, the measurements are expressed in terms of \textit{false positives, true positives, false negatives and true negatives}.Depending on the test, we continuously strived for either true negatives or true positives, since these terms states that the outcome of the test is also what were expected  beforehand (\textit{either true or false}). The other two terms implies the opposite, that the outcome was reversed to what was expected (\textit{either true or false}).
	
	
	
	\subsection{Evaluating accuracy} 
	When evaluating the accurateness of the fall detection algorithm we constructed a total of seven tests cases that would mimic real life situations that might trigger an alarm. Each test case was repeated 10 times on an iOS and Android device respectively. The tests were performed outdoors under equal circumstances. Test cases were as follows:
	\begin{itemize}
		\item Walk.
		\item Run.
		\item Jump.
		\item Falling while walking.
		\item Falling from 1 m.
		\item Falling from 1,5 m.
		\item Falling from 3 m.
	\end{itemize}
	
	
	The results from each of these test cases will now be presented in chronological order. 
	
	\subsubsection{Walk} 
	The walking test was performed by simply walking with the device in the trouser pocket. We walked for 15 meters and stopped for 10 seconds, then repeated the process. The 10 second stop is definitely long enough for a possible motion-event to fall through the state machine and consequently consult the classification engine. Should that happen, we still expect the classification engine to not classify the event as a fall. Walking should not produce an alarm and we expect the fall detection system to discard all motion-events and thus get \textit{true negatives}. The result can be seen in table \ref{table:walk-test}. 
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True negative & False positive & Success rate \\ \hline
			iOS     & 10            & 0              & 100\%        \\ \hline
			Android & 10            & 0              & 100\%        \\ \hline
		\end{tabular}
		\caption{The result of the walking test}
		\label{table:walk-test}
	\end{table}
	
	The result of the walking test shows a 100\% success rate on both iOS and Android. Possible fall event candidates are successfully discarded and walking does not produce an alarm.
	
	
	\subsubsection{Run}
	The run test was performed similar to the walking test in 1.1.1 but instead of walking, we would run for 15 meters and then stop for 10 seconds. Like the walking test, we expect the system to correctly discard all motion-events as non-fall. Running, like walking, should not produce any alarms and thus we expect to get \textit{true negatives}. The result can be see in table \ref{table:run-test}
	
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True negative & False positive & Success rate \\ \hline
			iOS     & 10            & 0              & 100\%        \\ \hline
			Android & 10            & 0              & 100\%        \\ \hline
		\end{tabular}
		\caption{The result of the running test}
		\label{table:run-test}
	\end{table}
	
	The result of the running test shows that equal to the walking test, the system successfully discards all motion-events as non-fall and does not produce an alarm.
	
	
	\subsubsection{Jump}
	The jump test was done by keeping the device in the trouser pocket and jump from a stare case elevated by approximately 40 cm and land on the feet on solid asphalt. This test, like the walk and run test, should preferably not produce any alarms. However, since the acceleration curve for a jump is very similar to that of a fall, we anticipated this test to be quite a challenge for our system since every jump would certainly slip through the state machine and get classified. The only barrier left is thus the classification engine who hopefully would classify each tests as a non-fall. We expected to get \textit{true negatives}. The results can be seen in table \ref{table:jump-test}.
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True negative & False positive & Success rate \\ \hline
			iOS     & 9            & 1             & 90\%        \\ \hline
			Android & 9            & 1              & 90\%        \\ \hline
		\end{tabular}
		\caption{The result of the jumping test}
		\label{table:jump-test}
	\end{table}
	
	The result of the jumping test shows that the system successfully discards 90\% of the jumps as non-falls on both devices. Only a single test per device were misclassified and resulted in an alarm.
	
	\subsubsection{Falling while walking}
	\label{section:falling-while-walking}
	We tried to simulate falling while walking by holding the device tightly against the hip and then walk for 15m and drop the device to the ground while still walking. The device would thus produce a curved fall to the ground in contrast to a straight line the would be the result if a person would fall from for eg. a ladder. In this test we expected the application to produce alarms, since falling while walking is indeed still a fall. Thus, we want the number of \textit{true-positives} be high and the number of \textit{false-negatives} to be low. The results can be seen in table \ref{table:fall-while-walk}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True positive & False negative & Success rate \\ \hline
			iOS     & 9            & 1             & 90\%        \\ \hline
			Android & 5            & 5              & 50\%        \\ \hline
		\end{tabular}
		\caption{The result of the falling while walking test}
		\label{table:fall-while-walk}
	\end{table}
	
	As can be seen, the iOS application successfully recognizes the event as a fall 90\% of the times where as the Android application had some difficulties to do so in 50\% of the times.
	
	
	\subsubsection{Falling  from 1m ( Simulate falling while standing on the ground)}
	\label{section:falling-from-1m}
	The  \textit{falling from 1m} test was performed by simply dropping the device to the ground from 1m altitude. The aim of this test was to replicate if a person would fall while standing still on the ground and having the device in the trouser pockets. Of course we were expecting the application to produce alarm in this case to the greatest extent. Thus, similar to the \textit{Falling while walking} test described in section \ref{section:falling-while-walking}, we anticipated the number if \textit{true-positives} to be high and the number of \textit{false-negatives} to be low. The result can be seen in table \ref{table:fall-from-1m}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True positive & False negative & Success rate \\ \hline
			iOS     & 8            & 2             & 80\%        \\ \hline
			Android & 7            & 3              & 70\%        \\ \hline
		\end{tabular}
		\caption{The result of the fall from 1m test}
		\label{table:fall-from-1m}
	\end{table}
	
	The test result shows that the iOS application successfully detects falls 80\% of the time where as the Android application had a success rate of 70\%. Once again, the iOS application has a slightly higher success rate,, but both of the applications detects falls in a vast majority of the tests. The reason for not getting a 100\% \textit{true-positives} might be due to that falling while standing on the ground does not produce a significant impact leading to the state machine firing.
	
	\subsubsection{Falling from 1.5 m (Simulate falling from eg. a chair)}
	\label{section:falling-from-1.5m}
	The \textit{falling from 1.5m} test, was performed in a similar fashion to \textit{Falling from 1m} in section \ref{section:falling-from-1m}, the only difference was that the device was elevated by another 0.5 meters. The aim of this test was to replicate a person falling from eg. a chair or some other common slightly elevated house hold apparel. In this test we expect the application to successfully detect falls on all occasions, thus, we anticipate the number of \textit{true-positives} to be high and the number of \textit{false-negatives to be low}. The result can be seen in table \ref{table:fall-from-1.5m}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True positive & False negative & Success rate \\ \hline
			iOS     & 9            & 1             & 90\%        \\ \hline
			Android & 7            & 3              & 70\%        \\ \hline
		\end{tabular}
		\caption{The result of the fall from 1.5m test}
		\label{table:fall-from-1.5m}
	\end{table}
	
	The result shown that the iOS application successfully detects fall in 90\% of the time where as the Android application has a success rate of 70\%
	
	
	\subsubsection{Falling from 3m (Simulate falling from a ladder)}
	The \textit{falling from 3m} test was conducted by letting the device fall freely from an altitude of 3m. The aim of this test was to simulate a fall from a higher elevation, namely a ladder or something similar. A fall from an altitude of 3m should definitely trigger an alarm and thus, like the tests in \ref{section:falling-from-1m} and \ref{section:falling-from-1.5m} we wanted to get as many \textit{true-positives} as possible, thus minimizing the number of \textit{false-negatives}. The results can be seen in table \ref{table:fall-from-3m}
	
	\begin{table}[H]
		\centering
		\begin{tabular}{|l|c|c|c|}
			\hline
			& True positive & False negative & Success rate \\ \hline
			iOS     & 9            & 1             & 90\%        \\ \hline
			Android & 10           & 0             & 100\%        \\ \hline
		\end{tabular}
		\caption{The result of the fall from 3m test}
		\label{table:fall-from-3m}
	\end{table}
	
	The result shown that the iOS application successfully detects fall in 90\% of the time where as the Android application has a success rate of 100\%
	
	\newpage
	
	\subsubsection{Summarizing accuracy}
	The overall results show that there exists some differences between the application running on an iOS device and it¬¥s Android counterpart. For each device, we can calculate the overall success rate by the equation in \ref{equation:overall-success}
	
	\begin{equation}
	\label{equation:overall-success}
	\sum_{k=1}^{n} S_{k} / n
	\end{equation}
	
	where:
	\begin{itemize}
		\item $n$ it the number ot test cases (7 in total)
		\item  $S$ is the success rate for that test case
	\end{itemize}
	
	
	This gives us overall success rate: 
	
	iOS: $(100 + 100 + 90 + 90 + 80 + 90 + 90) / 7 = 0.914 = 91\%$
	
	
	Android: $(100 +100 +90 +50 +70  + 70 + 100) / 7 = 0.828 = 83\%$
	
	
	One reason for the discrepancies between the application running on the iOS device and then one running on Android might be that the hardware accelerometer in the iOS device is of better quality and has better accuracy and precision. 
	
	
\newpage
	
	\section{Discussion \& Conclusions} \label{section:discussion}
	
	In this chapter, the methods used in the study and their implications are analysed, the research questions are answered followed by a discussion of sustainability and ethical considerations. Lastly, the research project is summarized and suggestions for future research is presented.
	
	\subsection{Methods \& Implications}
	
	This section analyses the methods used and the validity and reliability of this study.
	
	\subsubsection{Literature study}
	
	Since very similar studies had already been conducted before we started this research project, it was necessary to perform a literature study before starting the development process. Without this literature study we would not have known how previous researchers had reasoned and it would have been likely that we had repeated old mistakes and ended up with a lesser application.
	
	\subsubsection{Case study: Development}
	
	The case study consisting of developing an application gave us the opportunity to test different approaches and ideas to see if the algorithm could be improved. Developing an application was necessary since we did not have access to the source code of any existing application.
	
	\subsubsection{Case study: Evaluation}
	
	The evaluation of the application were conducted in a very small scale, and focusing on qualities of the application rather that performing tests with a lot of users. This means that we can only say that the application works well with condition that the circumstances are the same as in the evaluation. The limitations regarding evaluation include the fact that the evaluation of falls were performed by simply dropping the phone from an altitude. Our hope is that this is similar to an actual fall, but actual falls have not been tested. This is due to the fact that we could not perform the tests ourselves, since we would risk being injured during the test. We also did not have access to any kind of crash test dummy that could have been used for testing.
	
	\subsubsection{Validity \& Reliability}
	
	This section discusses the validity and reliability of the study.
	
	\parag{Validity}
	The term \textit{validity} is referring to whether or not the research methods are measuring what the study is trying to answer. With respect to the first research question, RQ1, regarding how a fall detection application can be created, it should be clear that the case study is addressing this question since it is exactly what is done in the case study. Regarding the second question, RQ2, it is not as obvious. To answer how this kind of application affects battery life, you could argue that it would be better to measure the battery consumption of many different fall detection applications and draw conclusions based on that. This would however give pure statistical knowledge saying that application A consumes X amount of battery per hour and application B consumes Y. Without insight into how these applications function internally this kind of information says nothing -- it would not be possible to say why application A consumes more power than B, or the other way around. To perform such a comparison, and to say why one application consumes more power than the other, it would be necessary to have the source code to the different applications. This was something that we did not have. Therefore this study can only say that if an application is developed the way that we did, you can expect that the battery consumption will be similar to the consumption in our measurements.
	
	\parag{Reliability}
	\textit{Reliability} refers to how replicable or repeatable the research project is. Another research project that asks the same questions and and uses the same methods should ideally come to the same conclusions. Our first method was to perform a literature study with the intention to find a good algorithm that were to be used as a starting point for the case study. It should be noted that another researcher, with different background and experiences may have found another algorithm as a better starting point and ended up with an application that implements fall detection entirely different, and thus could have ended up with different conclusions. However, if another researcher would use the same starting point as we did, and make the same decisions along the way, s/he should end up with the same result, and therefore the work is repeatable.
	
	\subsection{Test results}
	The tests results shows a high overall accuracy score. The overall accuracy for the iOS and Android applications are 91\% and 83\% respectively. These numbers suggest that, based on our tests, the application is doing what it should in 91\% vs. 83\% of the time. The application is in each case accurately discarding non-fall events and presenting an alarm in case of a real fall is detected to up to those percentages.  Though the implementation is practically identical in both cases, differences in training data and the precision of the accelerometer might be a reason why the tests result differ somewhat between the two implementations. Weather 91\% vs. 83\% accuracy is to consider accurate enough might be up for discussion, however, we conciser the tests to be successful because the methods we used when training our model was very much detected when we later tested it using similar methods. This leads us to think that machine learning is a good candidate for these kinds of predictions, and that even more, and better training data would very likely lead to an even higher accuracy. 
	
	
	\subsection{Revisiting research questions}
	
	This section answers the research questions.
	
	\textbf{RQ1} \textit{How can a mobile application, that detects falling accidents using modern smartphones, be created?}
	
	Based on the case study, we saw that a mobile application can be created so that it successfully detects falling accidents using the accelerometer in a modern smartphone. The case study showed that it was beneficial to use only the vector length of the accelerometer data instead of using the x, y and z components. Using a finite state machine was useful for filtering out possible falls, and a pre-trained neural network was suitable to classify these possible falls.
	
	\textbf{RQ2} \textit{How will such an application affect the battery life of the mobile phone?}
	
	Based on the evaluation of the application developed in the case study, we can see that a fall detection application does have a minor impact on the battery life of the smartphone running the application. The evaluation shows that this impact is small enough to make this kind of application useful.
	
	\subsection{Sustainability \& Ethics}
	
	In this section, sustainability \& ethics related to the project is discussed.
	
	\subsubsection{Sustainability}
	
	This project did not produce any new hardware, but used only hardware that already existed. Because of this it is hard to say in which way the project may have affected the environment. Since the project had a focus on minimizing the battery consumption of the application, and it turns out that the application had only a small impact on battery life, this project should have a minimal impact on the environment.
	
	The small impact that this project does have on the environment must also be but in relation to the benefits of the project. The architecture described could be used to create a refined application that detects falling accidents, which could be of great use for the society.
	
	\subsubsection{Ethics}
	
	The IEEE Computer Society defines eight main principles in their \textit{Software Engineering Code of Ethics} \cite{ieee-ethics}. Each principle is divided into several more specific statements.
	This section will briefly go through some of the principles and how it applies to this project.
	
	\parag{Public}
	The first principle, called public, states that software engineers should act in accordance with the public interest. This principle states that the interest of the software engineer and the employer should be moderated with public good. Our belief is that this application will be good for the public, so it does not violate this statement. Further our belief is that the software is safe to use and does not harm the environment. Thus, this project does not violate this principle.
	
	\parag{Client and Employer}
	The second principle states that one should act to suite the interests of the client and employer and consistent with the public interest. More specific software engineers should work in the area of their competence and be honest about limitations in their education or previous experience. Hopefully this report is transparent about the authors previous experience so that this project conforms to this principle.
	
	\parag{Product}
	The principle about the product states that their products should meet the highest professional standards possible. In our case, since the developed product is a prototype in a field where a limited set of applications exist, it is hard to say what the standard should be. However, it should be clear in the report what kind of result you can expect from this kind of application.
	
	\parag{Judgement}
	The judgement principle states that software engineers should maintain independence in their professional judgement, and not engage in bribery, double billing, etc. Since we have not engaged in such an activity the project does not violate this principle.
	
	\parag{Profession}
	The profession principle states that software engineers should advance the reputation of the profession by promote public knowledge of software engineering, and obey laws regarding their work. Since this thesis is open for anyone to read this helps promote public knowledge, and as far as we know we have obeyed all laws that are applicable.
	
	\parag{Self}
	The principle called self states that software engineers should participate in lifelong learning and strive to improve their knowledge. In this project, we have certainly learnt a lot so it conforms to this principle.
	
	\subsection{Summary}
	
	The purpose of this thesis was to evaluate the possibility of creating a mobile application that utilized sensors in the smartphone to detect falling accidents. Similar studies had already been conducted, and the result of some of these studies were used as a starting point. The development started with using a finite state machine to detect basic falls. The application was later refined by introducing machine learning beyond just a state machine. The state machine was used to gather data of potential falls, the collected data was analysed and specific features in the fall data were defined. These features were used in the creation of a pre-trained neural network model and this model proved to be functioning better than just the state machine. The research project ends in the conclusion that a fall detection application can successfully be created using this approach.
	
	An important aspect in the beginning of the project was the battery life of the application. The evaluation of the application showed that when using this approach, the battery consumption was not a problem.
	
	\subsection{Future research}
	
	This theses presents one possible way to create a fall detection application for smartphones, and the evaluation of the developed application is quite primitive. It would be possible to perform research with a wider evaluation. For example, one could perform experiments where a crash test dummy were equipped with a smartphone running the application. This crash test dummy could then be dropped from different heights and in different fall like events to see how well the application performs in a real life scenario.
	
	Another possibility would be to examine another way of creating a fall detection application, perhaps using another algorithm. It would then be possible to evaluate how well that application performs compared to the approach presented in this thesis.
	
	\newpage
		
	\bibliography{bib_common}
	\bibliographystyle{ieeetr}

\end{document}